/**
 ******************************************************************************
 * @file    main.c
 * @author  Auto-generated by STM32CubeIDE
 * @version V1.0
 * @brief   Default main function.
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning                                                                                           \
    "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "../../ucpp/codec/vs1002.hpp"
#include "../../ucpp/register.hpp"
#include "../../ucpp/sdcard/sdcard.hpp"
#include "../../ucpp/spi.hpp"
#include "../../ucpp/stm32/dma-regs.hpp"
#include "../../ucpp/stm32/gpio.hpp"
#include "../../ucpp/stm32/pwr-regs.hpp"
#include "../../ucpp/stm32/rcc.hpp"
#include "../../ucpp/stm32/sdmmc.hpp"
#include "../../ucpp/stm32/spi.hpp"
#include "../../ucpp/stm32/stm32f7.hpp"
#include "../../ucpp/strong_types.hpp"
#include <optional>
//#include <iostream> // <- beware this kills kittens
volatile int card_detect;
using namespace ucpp::stm32;

// SDMMC_D0 (PC8)  AF12
// SDMMC_D1 (PC9)  AF12
// SDMMC_D2 (PC10) AF12
// SDMMC_D3 (PC11) AF12
// SDMMC_CK (PC12) AF12
// SDMMC_CMD (PD2) AF12
void setup_clocks()
{
    //    using CR_t = decltype(stm32f7.rcc.CR);
    //    using CFGR_t = decltype(stm32f7.rcc.CFGR);
    //    stm32f7.rcc.CR |= 1;
    //    stm32f7.rcc.CFGR = 0;
    //    stm32f7.rcc.CR &= 0xFEF6FFFF;
    //    stm32f7.rcc.PLLCFGR = 0x24003010;
    //    stm32f7.rcc.CR &= 0xFFFBFFFF;
    //    stm32f7.rcc.CIR = 0;
    //    stm32f7.rcc.APB1ENR.PWREN = 1;
    //    stm32f7.rcc.APB2ENR.SYSCFGEN = 1;
    //    stm32f7.pwr.CR1.VOS = 1;
    //    stm32f7.rcc.CR = CR_t::HSION.shift(1) | CR_t::HSITRIM.shift(2);
    //    while (!stm32f7.rcc.CR.HSIRDY)
    //        ;
    //    stm32f7.rcc.CFGR = CFGR_t::SW0.shift(0) | CFGR_t::HPRE.shift(0) | CFGR_t::PPRE1.shift(0)
    //        | CFGR_t::PPRE2.shift(0);
}

template <typename gpio_t, gpio::alternate_function af, int I>
inline void _setup_all_af(gpio_t& gpio)
{
    using namespace gpio;
    alternate_function_field<I>(gpio) = af;
    mode_field<I>(gpio) = mode::alternate_function;
    speed_field<I>(gpio) = gpio::speed::very_high;
    output_type_field<I>(gpio) = gpio::output_type::push_pull;
}

template <typename gpio_t, gpio::alternate_function af, int... I>
inline void setup_all_af(gpio_t& gpio)
{
    (_setup_all_af<gpio_t, af, I>(gpio), ...);
}

inline void reset_sd()
{
    rcc::reset(stm32f7.rcc, stm32f7.sdmmc, true);
    for (volatile int i = 0; i < 4; i++)
        ;
    rcc::reset(stm32f7.rcc, stm32f7.sdmmc, false);
}
inline void setup_sd_io()
{
    reset_sd();
    setup_all_af<decltype(stm32f7.GPIOC), gpio::alternate_function::af12, 8, 9, 10, 11, 12>(
        stm32f7.GPIOC);
    setup_all_af<decltype(stm32f7.GPIOD), gpio::alternate_function::af12, 2>(stm32f7.GPIOD);
    using CLKCR = decltype(stm32f7.sdmmc.CLKCR);
    stm32f7.rcc.DKCFGR2.SDMMCSEL = 1;
    rcc::enable_clock(stm32f7.rcc, stm32f7.sdmmc);
    stm32f7.sdmmc.CLKCR
        = CLKCR::CLKDIV.shift((16 * 1000 * 1000) / (400 * 1000) - 2) | CLKCR::WIDBUS.shift(0);
    stm32f7.sdmmc.POWER.PWRCTRL = 3;
    stm32f7.sdmmc.CLKCR |= CLKCR::CLKEN.shift(1);
    for (volatile int i = 0; i < 1024 * 16; i++)
        ;
}

struct vs1002_io
{
    static constexpr void xcs(bool v) { stm32f7.GPIOB.od.get<9>() = v; }
    static constexpr void xdcs(bool v) { stm32f7.GPIOA.od.get<15>() = v; }
    static constexpr bool dreq() { return stm32f7.GPIOA.id.get<8>(); }
    static constexpr void reset(bool v) { stm32f7.GPIOI.od.get<2>() = v; }
};
// CS       = PB9
// SCK      = PB11
// MISO     = PB14
// MOSI     = PB15
// DREQ     = PA8
// BYTESYNC = PA15
// RESET    = PI2
inline void setup_codec_io()
{
    using namespace gpio;
    setup_all_af<decltype(stm32f7.GPIOB), gpio::alternate_function::af5, 14, 15>(stm32f7.GPIOB);
    setup_all_af<decltype(stm32f7.GPIOI), gpio::alternate_function::af5, 1>(stm32f7.GPIOI);
    mode_field<9>(stm32f7.GPIOB) = mode::output;
    speed_field<9>(stm32f7.GPIOB) = gpio::speed::very_high;
    output_type_field<9>(stm32f7.GPIOB) = gpio::output_type::push_pull;
    mode_field<15>(stm32f7.GPIOA) = mode::output;
    speed_field<15>(stm32f7.GPIOA) = gpio::speed::very_high;
    output_type_field<15>(stm32f7.GPIOA) = gpio::output_type::push_pull;
    mode_field<12>(stm32f7.GPIOI) = mode::output;
    speed_field<12>(stm32f7.GPIOI) = gpio::speed::very_high;
    output_type_field<12>(stm32f7.GPIOI) = gpio::output_type::push_pull;
    mode_field<8>(stm32f7.GPIOA) = mode::input;
    speed_field<8>(stm32f7.GPIOA) = gpio::speed::very_high;
}

void test_timer12()
{
    stm32f7.rcc.APB1ENR.TIM12EN = 1;
    *reinterpret_cast<volatile uint32_t*>(0x40001800) = 1;
}

int main(void)
{
    /* ==========================================================================
     *         Old style struct mapping for debug (gdb sugar)
       ==========================================================================*/
    volatile rcc::RCC_c_t* rcc = (rcc::RCC_c_t*)(stm32f7.rcc.address);
    volatile gpio::gpio_c_t* gpioc = (gpio::gpio_c_t*)(stm32f7.GPIOC.address);
    volatile gpio::gpio_c_t* gpioi = (gpio::gpio_c_t*)(stm32f7.GPIOI.address);
    volatile sdmmc::sdmmc_c_t* sdmmc1 = (sdmmc::sdmmc_c_t*)(stm32f7.sdmmc.address);
    volatile spi::spi_c_t* spi2 = (spi::spi_c_t*)(stm32f7.SPI2.address);
    volatile spi::spi_c_t* spi6 = (spi::spi_c_t*)(stm32f7.SPI6.address);
    volatile uint32_t* timer12_CR = reinterpret_cast<volatile uint32_t*>(0x40001800);
    // ===========================================================================
    setup_clocks();
    rcc::enable_clock(stm32f7.rcc, stm32f7.SPI2);
    rcc::enable_clock(stm32f7.rcc, stm32f7.SPI6);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOA);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOB);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOC);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOD);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOI);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOK);
    rcc::enable_clock(stm32f7.rcc, stm32f7.sdmmc);
    // test_timer12();
    // GPIO K3 = LCD backlight ctrl
    //    gpio::mode_field<3>(stm32f7.GPIOK) = gpio::mode::output;
    //    stm32f7.GPIOK.output_typer.get<3>() = gpio::output_type::open_drain;
    //    stm32f7.GPIOK.speedr.get<3>() = gpio::speed::very_high;
    // sdcard_init();
    setup_sd_io();
    setup_codec_io();
    ucpp::sdcard::Sdcard<ucpp::stm32::sdmmc::sdmmc_ctrlr<decltype(stm32f7.sdmmc)>> sdcrad;
    sdcrad.init();
    using codec_t = ucpp::codec::vs1002<ucpp::stm32::spi::SPI<decltype(stm32f7.SPI2)>, vs1002_io>;

    codec_t::init();
    int block = 2;
    for (;;)
    {
        char data[1024];
        sdcrad.read_block(block, data);
        for (int i = 0; i < 1024; i += 32)
        {
            codec_t::write_data(data + i);
        }
        block++;
    }
}
