/**
 ******************************************************************************
 * @file    main.c
 * @author  Auto-generated by STM32CubeIDE
 * @version V1.0
 * @brief   Default main function.
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning                                                                                           \
    "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "../../ucpp/register.hpp"
#include "../../ucpp/stm32/gpio.hpp"
#include "../../ucpp/stm32/rcc.hpp"
#include "../../ucpp/stm32/stm32f7.hpp"
#include "../../ucpp/strong_types.hpp"
#include <optional>
//#include <iostream> // <- beware this kills kittens
volatile int card_detect;
using namespace ucpp::stm32;

// SDMMC_D0 (PC8)  AF12
// SDMMC_D1 (PC9)  AF12
// SDMMC_D2 (PC10) AF12
// SDMMC_D3 (PC11) AF12
// SDMMC_CK (PC12) AF12
// SDMMC_CMD (PD2) AF12

template <typename gpio_t, int I>
inline void _setup_sd_io(gpio_t& gpio)
{
    using namespace gpio;
    alternate_function_field<I>(gpio) = alternate_function::af12;
    mode_field<I>(gpio) = mode::alternate_function;
    speed_field<I>(gpio) = gpio::speed::very_high;
    output_type_field<I>(gpio) = gpio::output_type::push_pull;
}

template <typename gpio_t, int... I>
inline void setup_sd_all_io(gpio_t& gpio)
{
    (_setup_sd_io<gpio_t, I>(gpio), ...);
}

inline void reset_sd()
{
    rcc::reset(stm32f7.rcc, stm32f7.sdmmc, true);
    for (volatile int i = 0; i < 4; i++)
        ;
    rcc::reset(stm32f7.rcc, stm32f7.sdmmc, false);
}
inline void setup_sd_io()
{
    reset_sd();
    setup_sd_all_io<decltype(stm32f7.GPIOC), 8, 9, 10, 11, 12>(stm32f7.GPIOC);
    setup_sd_all_io<decltype(stm32f7.GPIOD), 2>(stm32f7.GPIOD);
    using CLKCR = decltype(stm32f7.sdmmc.CLKCR);
    stm32f7.rcc.DKCFGR2.SDMMCSEL = 1;
    rcc::enable_clock(stm32f7.rcc, stm32f7.sdmmc);
    stm32f7.sdmmc.CLKCR
        = CLKCR::CLKDIV.shift((16 * 1000 * 1000) / (400 * 1000) - 2) | CLKCR::WIDBUS.shift(1);
    stm32f7.sdmmc.POWER.PWRCTRL = 3;
    stm32f7.sdmmc.CLKCR |= CLKCR::CLKEN.shift(1);
    for (volatile int i = 0; i < 1024 * 16; i++)
        ;
}

namespace
{

struct sd_no_response
{
};
struct sd_short_response
{
    uint32_t value;
};
struct sd_long_response
{
    uint32_t value[4];
};

enum class response_type_t
{
    no_resp,
    short_resp,
    long_resp
};

template <int CMD, typename resp_t, bool is_application_specific = false>
struct SD_CMD
{
    static inline constexpr int index = CMD;
    using response_type = resp_t;
    static inline constexpr bool application_specific = is_application_specific;
};

using CMD0 = SD_CMD<0, sd_no_response>;
using CMD8 = SD_CMD<8, sd_short_response>;
using CMD55 = SD_CMD<55, sd_short_response>;
using ACMD41 = SD_CMD<41, sd_short_response, true>;

template <typename response_t, typename T>
inline constexpr auto read_response(const T& sdmmc)
{
    if constexpr (std::is_same_v<response_t, sd_no_response>)
    {
        return true;
    }
    else if constexpr (std::is_same_v<response_t, sd_short_response>)
    {
        return std::optional<sd_short_response> { sd_short_response { uint32_t(sdmmc.RESP1) } };
    }
    else if constexpr (std::is_same_v<response_t, sd_long_response>)
    {
        return std::optional<sd_long_response> { sd_long_response {
            sdmmc.RESP1, sdmmc.RESP2, sdmmc.RESP3, sdmmc.RESP4 } };
    }
}
template <typename response_type>
inline constexpr int WAITRESP_v()
{
    if constexpr (std::is_same_v<response_type, sd_no_response>)
        return 0;
    if constexpr (std::is_same_v<response_type, sd_short_response>)
        return 1;
    if constexpr (std::is_same_v<response_type, sd_long_response>)
        return 3;
}

template <typename CMD>
inline constexpr auto sd_send_cmd_impl(uint32_t argument)
{
    volatile sdmmc::sdmmc_c_t* sdmmc1 = (sdmmc::sdmmc_c_t*)(stm32f7.sdmmc.address);
    using ICR = decltype(stm32f7.sdmmc.ICR);
    using cmd_reg = decltype(stm32f7.sdmmc.CMD);
    stm32f7.sdmmc.ICR |= ICR::CMDRENDC.shift(1) | ICR::CTIMEOUTC.shift(1) | ICR::CMDSENTC.shift(1);
    stm32f7.sdmmc.ARG = argument;
    stm32f7.sdmmc.CMD |= cmd_reg::CPSMEN.shift(1) | cmd_reg::CMDINDEX.shift(CMD::index)
        | cmd_reg::WAITRESP.shift(WAITRESP_v<typename CMD::response_type>());
    while (1)
    {
        if constexpr (std::is_same_v<typename CMD::response_type, sd_no_response>)
        {
            if (stm32f7.sdmmc.STA.CMDSENT)
                return read_response<typename CMD::response_type>(stm32f7.sdmmc);
        }
        else
        {
            if (stm32f7.sdmmc.STA.CMDREND)
            {
                return read_response<typename CMD::response_type>(stm32f7.sdmmc);
            }
            if (stm32f7.sdmmc.STA.CTIMEOUT)
            {
                return std::optional<typename CMD::response_type> { std::nullopt };
            }
        }
    }
}
}

template <typename CMD>
inline constexpr auto sd_send_cmd(uint32_t argument = 0)
{
    if constexpr (CMD::application_specific)
    {
        auto r = sd_send_cmd_impl<CMD55>(0);
        if (!r)
            return std::optional<typename CMD::response_type> { std::nullopt };
    }
    return sd_send_cmd_impl<CMD>(argument);
}

void sdcard_init()
{
    volatile sdmmc::sdmmc_c_t* sdmmc1 = (sdmmc::sdmmc_c_t*)(stm32f7.sdmmc.address);
    setup_sd_io();
    sd_send_cmd<CMD0>();
    for (volatile int i = 0; i < 1024; i++)
        ;
    auto r = sd_send_cmd<CMD8>(0x1aa);
    if (!r) // SD SC
    {
        // r = sd_send_cmd<41>(0);
        return;
    }
    else if (r->value != 0x1aa)
    {

    } // SD HC
    else
    {
        do
        {

            r = sd_send_cmd<ACMD41>(0x40000000);
        } while (!(r->value & 0x80000000));
    }
}

int main(void)
{
    /* ==========================================================================
     *         Old style struct mapping for debug (gdb sugar)
       ==========================================================================*/
    volatile rcc::RCC_c_t* rcc = (rcc::RCC_c_t*)(stm32f7.rcc.address);
    volatile gpio::gpio_c_t* gpioc = (gpio::gpio_c_t*)(stm32f7.GPIOC.address);
    volatile gpio::gpio_c_t* gpioi = (gpio::gpio_c_t*)(stm32f7.GPIOI.address);
    volatile sdmmc::sdmmc_c_t* sdmmc1 = (sdmmc::sdmmc_c_t*)(stm32f7.sdmmc.address);
    // ===========================================================================
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOI);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOC);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOD);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOK);
    // GPIO K3 = LCD backlight ctrl
    gpio::mode_field<3>(stm32f7.GPIOK) = gpio::mode::output;
    stm32f7.GPIOK.output_typer.get<3>() = gpio::output_type::open_drain;
    stm32f7.GPIOK.speedr.get<3>() = gpio::speed::very_high;
    sdcard_init();
    for (;;)
    {
        card_detect = stm32f7.GPIOC.id.get<13>();
        stm32f7.GPIOK.od.get<3>() = stm32f7.GPIOC.id.get<13>();
        int v = stm32f7.GPIOK.id; // check that int() is working
        // stm32f7.GPIOK.od = 10;
    }
}
