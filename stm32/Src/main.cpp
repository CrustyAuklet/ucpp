/**
 ******************************************************************************
 * @file    main.c
 * @author  Auto-generated by STM32CubeIDE
 * @version V1.0
 * @brief   Default main function.
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning                                                                                           \
    "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "../../ucpp/register.hpp"
#include "../../ucpp/sdcard/sdcard.hpp"
#include "../../ucpp/stm32/gpio.hpp"
#include "../../ucpp/stm32/rcc.hpp"
#include "../../ucpp/stm32/sdmmc.hpp"
#include "../../ucpp/stm32/spi.hpp"
#include "../../ucpp/spi.hpp"
#include "../../ucpp/codec/vs1002.hpp"
#include "../../ucpp/stm32/stm32f7.hpp"
#include "../../ucpp/strong_types.hpp"
#include <optional>
//#include <iostream> // <- beware this kills kittens
volatile int card_detect;
using namespace ucpp::stm32;

// SDMMC_D0 (PC8)  AF12
// SDMMC_D1 (PC9)  AF12
// SDMMC_D2 (PC10) AF12
// SDMMC_D3 (PC11) AF12
// SDMMC_CK (PC12) AF12
// SDMMC_CMD (PD2) AF12

template <typename gpio_t, int I>
inline void _setup_sd_io(gpio_t& gpio)
{
    using namespace gpio;
    alternate_function_field<I>(gpio) = alternate_function::af12;
    mode_field<I>(gpio) = mode::alternate_function;
    speed_field<I>(gpio) = gpio::speed::very_high;
    output_type_field<I>(gpio) = gpio::output_type::push_pull;
}

template <typename gpio_t, int... I>
inline void setup_sd_all_io(gpio_t& gpio)
{
    (_setup_sd_io<gpio_t, I>(gpio), ...);
}

inline void reset_sd()
{
    rcc::reset(stm32f7.rcc, stm32f7.sdmmc, true);
    for (volatile int i = 0; i < 4; i++)
        ;
    rcc::reset(stm32f7.rcc, stm32f7.sdmmc, false);
}
inline void setup_sd_io()
{
    reset_sd();
    setup_sd_all_io<decltype(stm32f7.GPIOC), 8, 9, 10, 11, 12>(stm32f7.GPIOC);
    setup_sd_all_io<decltype(stm32f7.GPIOD), 2>(stm32f7.GPIOD);
    using CLKCR = decltype(stm32f7.sdmmc.CLKCR);
    stm32f7.rcc.DKCFGR2.SDMMCSEL = 1;
    rcc::enable_clock(stm32f7.rcc, stm32f7.sdmmc);
    stm32f7.sdmmc.CLKCR
        = CLKCR::CLKDIV.shift((16 * 1000 * 1000) / (400 * 1000) - 2) | CLKCR::WIDBUS.shift(0);
    stm32f7.sdmmc.POWER.PWRCTRL = 3;
    stm32f7.sdmmc.CLKCR |= CLKCR::CLKEN.shift(1);
    for (volatile int i = 0; i < 1024 * 16; i++)
        ;
}

struct vs1002_io{
    static constexpr void xcs(bool v)
    {
        stm32f7.GPIOB.od.get<9>()=v;
    }
    static constexpr void xdcs(bool v)
    {
        stm32f7.GPIOA.od.get<15>()=v;
    }
    static constexpr bool dreq()
    {
        return stm32f7.GPIOA.id.get<8>();
    }
    static constexpr void reset(bool v)
    {

    }
};
//CS       = PB9
//SCK      = PB11
//MISO     = PB14
//MOSI     = PB15
//DREQ     = PA8
//BYTESYNC = PA15
inline void init_spi()
{

}

/* ==========================================================================
 *         Old style struct mapping for debug (gdb sugar)
   ==========================================================================*/
volatile rcc::RCC_c_t* rcc = (rcc::RCC_c_t*)(stm32f7.rcc.address);
volatile gpio::gpio_c_t* gpioc = (gpio::gpio_c_t*)(stm32f7.GPIOC.address);
volatile gpio::gpio_c_t* gpioi = (gpio::gpio_c_t*)(stm32f7.GPIOI.address);
volatile sdmmc::sdmmc_c_t* sdmmc1 = (sdmmc::sdmmc_c_t*)(stm32f7.sdmmc.address);
// ===========================================================================

int main(void)
{
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOI);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOC);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOD);
    rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOK);
    // GPIO K3 = LCD backlight ctrl
    gpio::mode_field<3>(stm32f7.GPIOK) = gpio::mode::output;
    stm32f7.GPIOK.output_typer.get<3>() = gpio::output_type::open_drain;
    stm32f7.GPIOK.speedr.get<3>() = gpio::speed::very_high;
    // sdcard_init();
    setup_sd_io();
    ucpp::sdcard::Sdcard<ucpp::stm32::sdmmc::sdmmc_ctrlr<decltype(stm32f7.sdmmc)>> sdcrad;
    sdcrad.init();
    using codec_t = ucpp::codec::vs1002<ucpp::stm32::spi::SPI<decltype (ucpp::stm32::stm32f7_t::SPI2)>,vs1002_io>;
    codec_t::init();
    int block = 0;
    for (;;)
    {
        char data[1024];
        sdcrad.read_block(block, data);
        for(int i=0;i<1024;i+=32)
        {
            codec_t::write_data(data+i);
        }
        block++;
    }
}
