/**
 ******************************************************************************
 * @file    main.c
 * @author  Auto-generated by STM32CubeIDE
 * @version V1.0
 * @brief   Default main function.
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning                                                                       \
    "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "../../ucpp/codec/vs1002.hpp"
#include "../../ucpp/register.hpp"
#include "../../ucpp/sdcard/sdcard.hpp"
#include "../../ucpp/spi.hpp"
#include "../../ucpp/stm32/dma-regs.hpp"
#include "../../ucpp/stm32/dma.hpp"
#include "../../ucpp/stm32/gpio.hpp"
#include "../../ucpp/stm32/pwr-regs.hpp"
#include "../../ucpp/stm32/rcc.hpp"
#include "../../ucpp/stm32/sdmmc.hpp"
#include "../../ucpp/stm32/spi.hpp"
#include "../../ucpp/stm32/stm32f7.hpp"
#include "../../ucpp/strong_types.hpp"
#include <optional>
//#include <iostream> // <- beware this kills kittens
volatile int card_detect;
using namespace ucpp::stm32;

// SDMMC_D0 (PC8)  AF12
// SDMMC_D1 (PC9)  AF12
// SDMMC_D2 (PC10) AF12
// SDMMC_D3 (PC11) AF12
// SDMMC_CK (PC12) AF12
// SDMMC_CMD (PD2) AF12
void setup_clocks() {
  stm32f7.rcc.PLLCFGR.PLLSRC = 0;
  stm32f7.rcc.PLLCFGR.PLLM4 = 1;
  stm32f7.rcc.PLLCFGR.PLLN7 = 1;
  stm32f7.rcc.PLLCFGR.PLLN6 = 1;
  stm32f7.rcc.PLLCFGR.PLLP0 = 1;
  stm32f7.rcc.CR.PLLON = 1;
  stm32f7.flash.ACR.LATENCY = 1;
  while (stm32f7.rcc.CR.PLLRDY == 0)
    ;
  stm32f7.rcc.CFGR.SW1 = 1;
}

template <typename gpio_t, gpio::alternate_function af, int I>
inline void _setup_all_af(gpio_t &gpio) {
  using namespace gpio;
  alternate_function_field<I>(gpio) = af;
  mode_field<I>(gpio) = mode::alternate_function;
  speed_field<I>(gpio) = gpio::speed::very_high;
  output_type_field<I>(gpio) = gpio::output_type::push_pull;
}

template <typename gpio_t, gpio::alternate_function af, int... I>
inline void setup_all_af(gpio_t &gpio) {
  (_setup_all_af<gpio_t, af, I>(gpio), ...);
}

inline void reset_sd() {
  rcc::reset(stm32f7.rcc, stm32f7.sdmmc, true);
  for (volatile int i = 0; i < 4; i++)
    ;
  rcc::reset(stm32f7.rcc, stm32f7.sdmmc, false);
}
inline void setup_sd_io() {
  reset_sd();
  setup_all_af<decltype(stm32f7.GPIOC), gpio::alternate_function::af12, 8, 12>(
      stm32f7.GPIOC);
  setup_all_af<decltype(stm32f7.GPIOD), gpio::alternate_function::af12, 2>(
      stm32f7.GPIOD);
  using CLKCR = decltype(stm32f7.sdmmc.CLKCR);
  stm32f7.rcc.DKCFGR2.SDMMCSEL = 1;
  rcc::enable_clock(stm32f7.rcc, stm32f7.sdmmc);
  stm32f7.sdmmc.CLKCR =
      CLKCR::CLKDIV.shift((48 * 1000 * 1000) / (400 * 1000) - 2) |
      CLKCR::WIDBUS.shift(0) | CLKCR::HWFC_EN.shift(1);
  stm32f7.sdmmc.DTIMER = 0xffffffff;
  stm32f7.sdmmc.POWER.PWRCTRL = 3;
  stm32f7.sdmmc.CLKCR |= CLKCR::CLKEN.shift(1);
  for (volatile int i = 0; i < 1024 * 16; i++)
    ;
}

struct vs1002_io {
  static constexpr void xcs(bool v) { stm32f7.GPIOB.od.get<9>() = v; }
  static constexpr void xdcs(bool v) { stm32f7.GPIOA.od.get<15>() = v; }
  static constexpr bool dreq() { return stm32f7.GPIOA.id.get<8>(); }
  static constexpr void reset(bool v) { stm32f7.GPIOI.od.get<2>() = v; }
};
// CS       = PB9
// SCK      = PB11
// MISO     = PB14
// MOSI     = PB15
// DREQ     = PA8
// BYTESYNC = PA15
// RESET    = PI2
inline void setup_codec_io() {
  using namespace gpio;
  setup_all_af<decltype(stm32f7.GPIOB), gpio::alternate_function::af5, 14, 15>(
      stm32f7.GPIOB);
  setup_all_af<decltype(stm32f7.GPIOI), gpio::alternate_function::af5, 1>(
      stm32f7.GPIOI);
  mode_field<9>(stm32f7.GPIOB) = mode::output;
  speed_field<9>(stm32f7.GPIOB) = gpio::speed::very_high;
  output_type_field<9>(stm32f7.GPIOB) = gpio::output_type::push_pull;
  mode_field<15>(stm32f7.GPIOA) = mode::output;
  speed_field<15>(stm32f7.GPIOA) = gpio::speed::very_high;
  output_type_field<15>(stm32f7.GPIOA) = gpio::output_type::push_pull;
  mode_field<12>(stm32f7.GPIOI) = mode::output;
  speed_field<12>(stm32f7.GPIOI) = gpio::speed::very_high;
  output_type_field<12>(stm32f7.GPIOI) = gpio::output_type::push_pull;
  mode_field<8>(stm32f7.GPIOA) = mode::input;
  speed_field<8>(stm32f7.GPIOA) = gpio::speed::very_high;
}

void enable_peripherals() {
  rcc::enable_clock(stm32f7.rcc, stm32f7.DMA2);
  rcc::enable_clock(stm32f7.rcc, stm32f7.SPI2);
  rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOA);
  rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOB);
  rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOC);
  rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOD);
  rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOI);
  rcc::enable_clock(stm32f7.rcc, stm32f7.GPIOK);
}

int main(void) {
  using sd_regs = decltype(stm32f7.sdmmc);
  using dma2_regs = decltype(stm32f7.DMA2);
  using dma2_ctrlr = dma::dma_ctrlr<dma2_regs>;
  using sdmmc_ctrlr = ucpp::stm32::sdmmc::sdmmc_ctrlr<sd_regs, dma2_ctrlr>;
  using codec_spi = ucpp::stm32::spi::SPI<decltype(stm32f7.SPI2)>;

  ucpp::sdcard::Sdcard<sdmmc_ctrlr> sdcrad;
  using codec_t = ucpp::codec::vs1002<codec_spi, vs1002_io, 25000000>;

  setup_clocks();
  enable_peripherals();
  setup_sd_io();
  setup_codec_io();

  sdcrad.init();
  codec_t::init();
  sdcrad.select();

  ucpp::sdcard::block_address_t block_address{0};
  char data[512];
  for (;;) {
    sdcrad.read_block(block_address, data);
    for (int i = 0; i < 512; i += 32) {
      codec_t::write_data(data + i);
    }
    block_address += 1;
  }
}
