/**
 ******************************************************************************
 * @file    main.c
 * @author  Auto-generated by STM32CubeIDE
 * @version V1.0
 * @brief   Default main function.
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning                                                                       \
    "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "../../ucpp/register.hpp"
#include "../../ucpp/stm32/gpio.hpp"
#include "../../ucpp/stm32/rcc.hpp"
#include "../../ucpp/stm32/stm32f7.hpp"

using namespace ucpp;
using namespace ucpp::strong_types;
using namespace ucpp::stm32;
using namespace ucpp::gpio;
// LED on PB8
// USER Push Button on PI11

struct duty_cycle_t
    : strong_type<uint32_t> {
  using strong_type::strong_type;
};

struct period_t
    : strong_type<uint32_t> {
  using strong_type::strong_type;
};

inline void wait(int delay) {
  for (volatile int i=delay; i; i--)
    ;
}

template <typename duty_cycle_fn_t, typename period_fn_t,
          typename set_led_state_fn_t>
inline void pwm_loop(const duty_cycle_fn_t &get_duty_cycle,
                     const period_fn_t &get_period,
                     const set_led_state_fn_t &set_led) {
  int loop_counter = 0;
  while (1) {
     duty_cycle_t duty_cycle = get_duty_cycle(loop_counter);
     period_t period = get_period(loop_counter);
    for (int i = 0; i < 4; i++) {
      int high = (period.value() * duty_cycle.value()) / 100;
      int low = period.value() - high;
      set_led(0);
      wait(low);
      set_led(1);
      wait(high);
      loop_counter++;
    }
  }
}

inline auto compute_duty(int step)
{
    return duty_cycle_t{step%100};
}

inline auto compute_period(int step)
{
    if(stm32f7.GPIOI.id.get<11>())
        return period_t{1024 * 16};
    else
        return period_t{1024*64};
}

int main(void) {
  rcc::enable_clock(stm32f7, stm32f7.GPIOB);
  rcc::enable_clock(stm32f7, stm32f7.GPIOI);
  set_direction(stm32f7, GPIOB8, stm32::gpio::mode::output);
  set_direction(stm32f7, GPIOI11, stm32::gpio::mode::input);
  for (;;) {
    pwm_loop(compute_duty, compute_period,
             [](bool state) { stm32f7.GPIOB.od.get<8>() = state; });
  }
}
